# Firebase Integration Guide for Ascenity

## Overview

Ascenity uses Firebase as its backend platform, leveraging several Firebase services for authentication, data storage, and analytics. This document outlines how Firebase is integrated into the application and best practices for working with Firebase services.

## Firebase Services Used

### 1. Firebase Authentication

Used for user authentication and identity management.

**Features:**
- Google Sign-In integration
- Auth state persistence
- Secure authentication flow

### 2. Cloud Firestore

Used as the primary database for storing user data.

**Collections:**
- `users`: User profile information
- `users/{userId}/entries`: Journal entries
- `users/{userId}/moods`: Mood tracking data

### 3. Firebase Analytics (Planned)

Will be used for tracking app usage and user engagement.

## Setup and Configuration

### Prerequisites

- Firebase project created in Firebase Console
- FlutterFire CLI installed
- Firebase services enabled (Authentication, Firestore)

### Configuration

Firebase is initialized in the `main.dart` file:

```dart
void main() async {
  // Ensure Flutter bindings are initialized
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  runApp(const MyApp());
}
```

The `firebase_options.dart` file contains platform-specific configuration and is generated by the FlutterFire CLI.

## Authentication Implementation

### AuthService Class

The `AuthService` class (`lib/services/auth_service.dart`) manages all authentication-related functionality:

```dart
class AuthService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn();

  // Stream to listen for auth state changes
  Stream<User?> get user => _auth.authStateChanges();

  // Sign in with Google
  Future<UserCredential?> signInWithGoogle() async {
    // Implementation details...
  }

  // Sign out
  Future<void> signOut() async {
    // Implementation details...
  }
}
```

### AuthGate Widget

The `AuthGate` widget (`lib/widgets/auth_gate.dart`) handles conditional rendering based on authentication state:

```dart
class AuthGate extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snapshot) {
        // User is not signed in
        if (!snapshot.hasData) {
          return const LoginScreen();
        }
        // User is signed in
        return const MainShell();
      },
    );
  }
}
```

## Firestore Data Model

### User Data

Each user document contains basic profile information:

```
users/{userId}
  |- displayName: string
  |- email: string
  |- photoURL: string
  |- createdAt: timestamp
```

### Journal Entries

Journal entries are stored in a subcollection:

```
users/{userId}/entries/{entryId}
  |- text: string
  |- mood: string
  |- date: timestamp
  |- aiSentimentScore: number (optional)
  |- aiSentimentLabel: string (optional)
  |- aiSuggestedAction: string (optional)
  |- aiPositiveHits: array<string> (optional)
  |- aiNegativeHits: array<string> (optional)
  |- prompt: string (optional)
```

### Mood Data

Mood tracking data is stored in a subcollection:

```
users/{userId}/moods/{moodId}
  |- moodScore: number
  |- moodLabel: string
  |- timestamp: timestamp
```

## Firestore Service Implementation

The `FirestoreService` class (`lib/services/firestore_services.dart`) handles all Firestore operations:

```dart
class FirestoreService {
  final FirebaseFirestore _db = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Add a new journal entry
  Future<SentimentResult> addEntry(String text, String mood, {String? prompt}) async {
    // Implementation details...
  }

  // Get a stream of journal entries
  Stream<List<JournalEntry>> getEntriesStream() {
    // Implementation details...
  }

  // Save a mood entry
  Future<void> saveMoodEntry(int moodLevel, String moodLabel) async {
    // Implementation details...
  }

  // Additional methods for querying and aggregating data
  // ...
}
```

## Best Practices

### Security

1. **Security Rules**: Implement proper Firestore security rules to ensure users can only access their own data.

Example security rules:
```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null;
      
      match /entries/{entryId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      match /moods/{moodId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
  }
}
```

2. **Authentication**: Never store sensitive user information in Firestore.

### Performance

1. **Query Optimization**: Use indexes and limit queries to improve performance.

2. **Batch Operations**: Use batch writes for multiple document updates.

```dart
final batch = _db.batch();
// Add batch operations
await batch.commit();
```

3. **Pagination**: Implement pagination for large collections.

```dart
final lastDoc = querySnapshot.docs.last;
final nextQuery = query.startAfterDocument(lastDoc).limit(10);
```

### Offline Support

1. **Enable Offline Persistence**:

```dart
FirebaseFirestore.instance.settings = 
    Settings(persistenceEnabled: true, cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED);
```

2. **Handle Network State**: Provide feedback when device is offline.

## Error Handling

1. **Graceful Degradation**: Handle Firebase errors gracefully with user-friendly messages.

2. **Retry Logic**: Implement retry logic for critical operations.

```dart
Future<void> retryOperation(Future<void> Function() operation) async {
  int attempts = 0;
  while (attempts < 3) {
    try {
      return await operation();
    } catch (e) {
      attempts++;
      if (attempts >= 3) rethrow;
      await Future.delayed(Duration(seconds: 1 * attempts));
    }
  }
}
```

## Testing Firebase Integration

1. **Firebase Emulator**: Use Firebase emulator for local development and testing.

2. **Mock Services**: Create mock Firebase services for unit testing.

3. **Test User Accounts**: Use dedicated test accounts for integration testing.

## Data Migration Strategies

1. **Schema Versioning**: Include a version field in documents to track schema changes.

2. **Background Migration**: Use Cloud Functions to migrate data in the background.

3. **Incremental Updates**: Update data incrementally as users interact with it.